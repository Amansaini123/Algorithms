//  Floyd warshall 
//  All pair shortest path algorithm
//  Dynamic Programming i.e explore all the possible outcomes and then pick the best one
//  Similar to applying dijstra to all the nodes
//  Say shortest distance via 1 and then do not change the path of 1

# include<bits/stdc++.h>
# define V 4
# define INF 99999

using namespace std;

void fuck(int graph[][V])
{
    int dist[V][V],i,j,k;
    
    // Initialzing the solution matrix same as input graph
    for(int i=0;i<V;i++)
        for(int j=0;j<V;j++)
            dist[i][j]=graph[i][j];
    
    
    // Take all k as intermediate vertex
    for(k=0;k<V;k++)
        // Pick all vertex as source vertex one by one 
        for(i=0;i<V;i++)
            // Pick all vertex as the destination vertex for all the above sourcevertex
            for(j=0;j<V;j++)
                if (dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
    
    
    
    for(int i=0;i<V;i++){
        for(int j=0;j<V;j++){
            if(dist[i][j]==INF){
                cout<<"INF"<<" ";
            }
            else{
                cout<<dist[i][j]<<" ";
            }
        }
        cout<<endl;
    }
    
}
int main()
{
    int graph[V][V]={
        {0,5,INF,10},
        {INF,0,3,INF},
        {INF,INF,0,1},
        {INF,INF,INF,0}
    };
    
    fuck(graph);
}
